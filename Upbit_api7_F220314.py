{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 3,
   "id": "57a2bc29",
   "metadata": {},
   "outputs": [
    {
     "ename": "KeyboardInterrupt",
     "evalue": "",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)",
      "\u001b[1;32mC:\\Users\\Public\\Documents\\ESTsoft\\CreatorTemp/ipykernel_15008/2613938650.py\u001b[0m in \u001b[0;36m<module>\u001b[1;34m\u001b[0m\n\u001b[0;32m    364\u001b[0m         \u001b[1;32mfor\u001b[0m \u001b[0msymbol\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mkrw_tickers\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    365\u001b[0m             \u001b[1;31m#최근 체결된 코인 정렬\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 366\u001b[1;33m             \u001b[0morder_done\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mupbit\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget_order\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msymbol\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mstate\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m\"cancel\"\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;33m+\u001b[0m\u001b[0mupbit\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget_order\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msymbol\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mstate\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;34m\"done\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    367\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    368\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[1;33m(\u001b[0m \u001b[1;33m[\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m!=\u001b[0m \u001b[0morder_done\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m \u001b[1;31m#빈 배열이 있을때 오류가 나지않게하기위해서\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\pyupbit\\exchange_api.py\u001b[0m in \u001b[0;36mget_order\u001b[1;34m(self, ticker_or_uuid, state, kind, contain_req)\u001b[0m\n\u001b[0;32m    289\u001b[0m                         }\n\u001b[0;32m    290\u001b[0m                 \u001b[0mheaders\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_request_headers\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mdata\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 291\u001b[1;33m                 \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0m_send_get_request\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mheaders\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdata\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mdata\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    292\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    293\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mcontain_req\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\pyupbit\\request_api.py\u001b[0m in \u001b[0;36m_send_get_request\u001b[1;34m(url, headers, data)\u001b[0m\n\u001b[0;32m     64\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     65\u001b[0m \u001b[1;32mdef\u001b[0m \u001b[0m_send_get_request\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdata\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 66\u001b[1;33m     \u001b[0mresp\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mrequests\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mheaders\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mheaders\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mdata\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mdata\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     67\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mHTTP_RESP_CODE_START\u001b[0m \u001b[1;33m<=\u001b[0m \u001b[0mresp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mstatus_code\u001b[0m \u001b[1;33m<\u001b[0m \u001b[0mHTTP_RESP_CODE_END\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     68\u001b[0m         \u001b[0mremaining_req\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mresp\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mheaders\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mget\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'Remaining-Req'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\requests\\api.py\u001b[0m in \u001b[0;36mget\u001b[1;34m(url, params, **kwargs)\u001b[0m\n\u001b[0;32m     73\u001b[0m     \"\"\"\n\u001b[0;32m     74\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 75\u001b[1;33m     \u001b[1;32mreturn\u001b[0m \u001b[0mrequest\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m'get'\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mparams\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mparams\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     76\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     77\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\requests\\api.py\u001b[0m in \u001b[0;36mrequest\u001b[1;34m(method, url, **kwargs)\u001b[0m\n\u001b[0;32m     59\u001b[0m     \u001b[1;31m# cases, and look like a memory leak in others.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     60\u001b[0m     \u001b[1;32mwith\u001b[0m \u001b[0msessions\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mSession\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mas\u001b[0m \u001b[0msession\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m---> 61\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0msession\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrequest\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmethod\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mmethod\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0murl\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m     62\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m     63\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\requests\\sessions.py\u001b[0m in \u001b[0;36mrequest\u001b[1;34m(self, method, url, params, data, headers, cookies, files, auth, timeout, allow_redirects, proxies, hooks, stream, verify, cert, json)\u001b[0m\n\u001b[0;32m    540\u001b[0m         }\n\u001b[0;32m    541\u001b[0m         \u001b[0msend_kwargs\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mupdate\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msettings\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 542\u001b[1;33m         \u001b[0mresp\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msend\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprep\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0msend_kwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    543\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    544\u001b[0m         \u001b[1;32mreturn\u001b[0m \u001b[0mresp\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\requests\\sessions.py\u001b[0m in \u001b[0;36msend\u001b[1;34m(self, request, **kwargs)\u001b[0m\n\u001b[0;32m    653\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    654\u001b[0m         \u001b[1;31m# Send the request\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 655\u001b[1;33m         \u001b[0mr\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0madapter\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msend\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mrequest\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    656\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    657\u001b[0m         \u001b[1;31m# Total elapsed time of the request (approximately)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\requests\\adapters.py\u001b[0m in \u001b[0;36msend\u001b[1;34m(self, request, stream, timeout, verify, cert, proxies)\u001b[0m\n\u001b[0;32m    437\u001b[0m         \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    438\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[0mchunked\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 439\u001b[1;33m                 resp = conn.urlopen(\n\u001b[0m\u001b[0;32m    440\u001b[0m                     \u001b[0mmethod\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mrequest\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmethod\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    441\u001b[0m                     \u001b[0murl\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0murl\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\u001b[0m in \u001b[0;36murlopen\u001b[1;34m(self, method, url, body, headers, retries, redirect, assert_same_host, timeout, pool_timeout, release_conn, chunked, body_pos, **response_kw)\u001b[0m\n\u001b[0;32m    697\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    698\u001b[0m             \u001b[1;31m# Make the request on the httplib connection object.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 699\u001b[1;33m             httplib_response = self._make_request(\n\u001b[0m\u001b[0;32m    700\u001b[0m                 \u001b[0mconn\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    701\u001b[0m                 \u001b[0mmethod\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\u001b[0m in \u001b[0;36m_make_request\u001b[1;34m(self, conn, method, url, timeout, chunked, **httplib_request_kw)\u001b[0m\n\u001b[0;32m    380\u001b[0m         \u001b[1;31m# Trigger any extra validation we need to do.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    381\u001b[0m         \u001b[1;32mtry\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 382\u001b[1;33m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_validate_conn\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mconn\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    383\u001b[0m         \u001b[1;32mexcept\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mSocketTimeout\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mBaseSSLError\u001b[0m\u001b[1;33m)\u001b[0m \u001b[1;32mas\u001b[0m \u001b[0me\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    384\u001b[0m             \u001b[1;31m# Py2 raises this as a BaseSSLError, Py3 raises it as socket timeout.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\connectionpool.py\u001b[0m in \u001b[0;36m_validate_conn\u001b[1;34m(self, conn)\u001b[0m\n\u001b[0;32m   1008\u001b[0m         \u001b[1;31m# Force connect early to allow us to validate the connection.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1009\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[0mgetattr\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mconn\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;34m\"sock\"\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m  \u001b[1;31m# AppEngine might not have  `.sock`\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1010\u001b[1;33m             \u001b[0mconn\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mconnect\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1011\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1012\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[1;32mnot\u001b[0m \u001b[0mconn\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mis_verified\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\connection.py\u001b[0m in \u001b[0;36mconnect\u001b[1;34m(self)\u001b[0m\n\u001b[0;32m    414\u001b[0m             \u001b[0mcontext\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mload_default_certs\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    415\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 416\u001b[1;33m         self.sock = ssl_wrap_socket(\n\u001b[0m\u001b[0;32m    417\u001b[0m             \u001b[0msock\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mconn\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    418\u001b[0m             \u001b[0mkeyfile\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mkey_file\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\util\\ssl_.py\u001b[0m in \u001b[0;36mssl_wrap_socket\u001b[1;34m(sock, keyfile, certfile, cert_reqs, ca_certs, server_hostname, ssl_version, ciphers, ssl_context, ca_cert_dir, key_password, ca_cert_data, tls_in_tls)\u001b[0m\n\u001b[0;32m    447\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    448\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0msend_sni\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 449\u001b[1;33m         ssl_sock = _ssl_wrap_socket_impl(\n\u001b[0m\u001b[0;32m    450\u001b[0m             \u001b[0msock\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mcontext\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mtls_in_tls\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mserver_hostname\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mserver_hostname\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    451\u001b[0m         )\n",
      "\u001b[1;32m~\\anaconda3\\lib\\site-packages\\urllib3\\util\\ssl_.py\u001b[0m in \u001b[0;36m_ssl_wrap_socket_impl\u001b[1;34m(sock, ssl_context, tls_in_tls, server_hostname)\u001b[0m\n\u001b[0;32m    491\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    492\u001b[0m     \u001b[1;32mif\u001b[0m \u001b[0mserver_hostname\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 493\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mssl_context\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mwrap_socket\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msock\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mserver_hostname\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mserver_hostname\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    494\u001b[0m     \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    495\u001b[0m         \u001b[1;32mreturn\u001b[0m \u001b[0mssl_context\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mwrap_socket\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0msock\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\ssl.py\u001b[0m in \u001b[0;36mwrap_socket\u001b[1;34m(self, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs, server_hostname, session)\u001b[0m\n\u001b[0;32m    498\u001b[0m         \u001b[1;31m# SSLSocket class handles server_hostname encoding before it calls\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    499\u001b[0m         \u001b[1;31m# ctx._wrap_socket()\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 500\u001b[1;33m         return self.sslsocket_class._create(\n\u001b[0m\u001b[0;32m    501\u001b[0m             \u001b[0msock\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0msock\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    502\u001b[0m             \u001b[0mserver_side\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mserver_side\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\ssl.py\u001b[0m in \u001b[0;36m_create\u001b[1;34m(cls, sock, server_side, do_handshake_on_connect, suppress_ragged_eofs, server_hostname, context, session)\u001b[0m\n\u001b[0;32m   1038\u001b[0m                         \u001b[1;31m# non-blocking\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1039\u001b[0m                         \u001b[1;32mraise\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m\"do_handshake_on_connect should not be specified for non-blocking sockets\"\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1040\u001b[1;33m                     \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdo_handshake\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1041\u001b[0m             \u001b[1;32mexcept\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mOSError\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mValueError\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1042\u001b[0m                 \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mclose\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;32m~\\anaconda3\\lib\\ssl.py\u001b[0m in \u001b[0;36mdo_handshake\u001b[1;34m(self, block)\u001b[0m\n\u001b[0;32m   1307\u001b[0m             \u001b[1;32mif\u001b[0m \u001b[0mtimeout\u001b[0m \u001b[1;33m==\u001b[0m \u001b[1;36m0.0\u001b[0m \u001b[1;32mand\u001b[0m \u001b[0mblock\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1308\u001b[0m                 \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msettimeout\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;32mNone\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1309\u001b[1;33m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_sslobj\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mdo_handshake\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1310\u001b[0m         \u001b[1;32mfinally\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1311\u001b[0m             \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msettimeout\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mtimeout\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n",
      "\u001b[1;31mKeyboardInterrupt\u001b[0m: "
     ]
    }
   ],
   "source": [
    "\n",
    "############################### 모듈 import #####################################\n",
    "\n",
    "import pyupbit\n",
    "import jwt\n",
    "import uuid\n",
    "import hashlib\n",
    "from urllib.parse import urlencode\n",
    "import pandas as pd\n",
    "import time\n",
    "import webbrowser\n",
    "import numpy as np\n",
    "import time\n",
    "import requests\n",
    "import datetime \n",
    "\n",
    "\n",
    "############################### 프로그램 상수 #####################################\n",
    "access_key = \"9N4F5hD4a7KMemJP3KMfOT7qsNB2m1H60f5di5ol\"\n",
    "secret_key = \"Do6mrNXjNC2pSyvGb5b0x3EcCJRNxxZb1ixNnEdX\"\n",
    "myToken = \"xoxb-2871923715953-2852604955318-wu9blfcJVprOgvwtjcrHncNl\"\n",
    "\n",
    "#투자금액\n",
    "invest_money = 300000\n",
    "\n",
    "#거래할 코인\n",
    "krw_tickers = ['KRW-BTC', 'KRW-ETH', 'KRW-NEO', 'KRW-MTL', 'KRW-LTC', 'KRW-XRP', 'KRW-ETC', 'KRW-OMG','KRW-SNT','KRW-WAVES', \n",
    "               'KRW-XEM', 'KRW-QTUM', 'KRW-LSK', 'KRW-STEEM', 'KRW-XLM', 'KRW-ARDR', 'KRW-ARK', 'KRW-STORJ','KRW-GRS', 'KRW-REP', \n",
    "               'KRW-ADA', 'KRW-SBD', 'KRW-POWR', 'KRW-BTG', 'KRW-ICX', 'KRW-EOS', 'KRW-TRX', 'KRW-SC', 'KRW-ONT', 'KRW-ZIL',\n",
    "               'KRW-POLY', 'KRW-ZRX', 'KRW-LOOM', 'KRW-BCH', 'KRW-BAT', 'KRW-IOST', 'KRW-RFR', 'KRW-CVC', 'KRW-IQ', 'KRW-IOTA', \n",
    "               'KRW-MFT', 'KRW-ONG', 'KRW-GAS', 'KRW-UPP', 'KRW-ELF', 'KRW-KNC', 'KRW-BSV', 'KRW-THETA', 'KRW-QKC', 'KRW-BTT', \n",
    "               'KRW-MOC', 'KRW-ENJ', 'KRW-TFUEL', 'KRW-MANA', 'KRW-ANKR', 'KRW-AERGO', 'KRW-ATOM', 'KRW-TT', 'KRW-CRE', 'KRW-MBL',\n",
    "               'KRW-WAXP', 'KRW-HBAR', 'KRW-MED', 'KRW-MLK', 'KRW-STPT', 'KRW-ORBS', 'KRW-VET', 'KRW-CHZ', 'KRW-STMX', 'KRW-DKA',\n",
    "               'KRW-HIVE', 'KRW-KAVA', 'KRW-AHT', 'KRW-LINK', 'KRW-XTZ', 'KRW-BORA', 'KRW-JST', 'KRW-CRO', 'KRW-TON', 'KRW-SXP',\n",
    "               'KRW-HUNT', 'KRW-PLA', 'KRW-DOT', 'KRW-SRM','KRW-MVL','KRW-STRAX','KRW-AQT','KRW-GLM','KRW-SSX','KRW-META',\n",
    "               'KRW-FCT2','KRW-CBK','KRW-SAND','KRW-HUM','KRW-DOGE','KRW-STRK','KRW-PUNDIX','KRW-FLOW','KRW-DAWN','KRW-AXS', \n",
    "               'KRW-STX','KRW-XEC']\n",
    "\n",
    "\n",
    "#익절,손절 퍼센트\n",
    "goodsell_percent = 1.06\n",
    "deadsell_percent = 0.93\n",
    "buydown_percent = 0.998\n",
    "aftergoodsell_percent = 0.985 #goodsell각 이후 1.5퍼 떨어지면 매도\n",
    "wantgood_sellminus_percent = 0.985  #wantgood_sellminus_percent퍼 떨어지면 wantgood리스트에 보관 후에 3퍼이상일때 매도\n",
    "\n",
    "################################# 함수 ####################################\n",
    "upbit = pyupbit.Upbit(access_key, secret_key) # pyupbit 사용하기 위함\n",
    "\n",
    "\n",
    "#슬랙 message\n",
    "def post_message(token, channel, text):\n",
    "    \"\"\"슬랙 메시지 전송\"\"\"\n",
    "    response = requests.post(\"https://slack.com/api/chat.postMessage\",\n",
    "        headers={\"Authorization\": \"Bearer \"+token},\n",
    "        data={\"channel\": channel,\"text\": text}\n",
    "    )\n",
    "\n",
    "\n",
    "#스토캐스틱rsi 1week (반환값 매수조건만족시 True 나머지는 False)\n",
    "def stockrsiweeks(symbol):\n",
    "    url = \"https://api.upbit.com/v1/candles/weeks\"\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    series=df['trade_price'].iloc[::-1]\n",
    "\n",
    "    df = pd.Series(df['trade_price'].values)\n",
    "\n",
    "    period=19\n",
    "    smoothK=3\n",
    "    smoothD=3\n",
    "\n",
    "    delta = series.diff().dropna()\n",
    "    ups = delta * 0\n",
    "    downs = ups.copy()\n",
    "    ups[delta > 0] = delta[delta > 0]\n",
    "    downs[delta < 0] = -delta[delta < 0]\n",
    "    ups[ups.index[period-1]] = np.mean( ups[:period] )\n",
    "    ups = ups.drop(ups.index[:(period-1)])\n",
    "    downs[downs.index[period-1]] = np.mean( downs[:period] )\n",
    "    downs = downs.drop(downs.index[:(period-1)])\n",
    "    rs = ups.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() /          downs.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() \n",
    "    rsi = 100 - 100 / (1 + rs)\n",
    "\n",
    "    stochrsi  = (rsi - rsi.rolling(period).min()) / (rsi.rolling(period).max() - rsi.rolling(period).min())\n",
    "    stochrsi_K = stochrsi.rolling(smoothK).mean()\n",
    "    stochrsi_D = stochrsi_K.rolling(smoothD).mean()\n",
    "\n",
    "    \n",
    "    \n",
    "\n",
    "    condition = False;\n",
    "    yyester_K=stochrsi_K.iloc[-3]*100\n",
    "    yyester_D=stochrsi_D.iloc[-3]*100\n",
    "    yester_K=stochrsi_K.iloc[-2]*100\n",
    "    yester_D=stochrsi_D.iloc[-2]*100\n",
    "    today_K=stochrsi_K.iloc[-1]*100\n",
    "    today_D=stochrsi_D.iloc[-1]*100\n",
    "    if(yester_K<today_K and today_K > today_D):\n",
    "        condition=True\n",
    "    return condition\n",
    "\n",
    "\n",
    "#스토캐스틱 60min (반환값 매수조건만족시 True 나머지는 False)\n",
    "def stockrsi60(symbol):\n",
    "    url = \"https://api.upbit.com/v1/candles/days\"\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    series=df['trade_price'].iloc[::-1]\n",
    "\n",
    "    df = pd.Series(df['trade_price'].values)\n",
    "\n",
    "    period=19\n",
    "    smoothK=3\n",
    "    smoothD=3\n",
    "\n",
    "    delta = series.diff().dropna()\n",
    "    ups = delta * 0\n",
    "    downs = ups.copy()\n",
    "    ups[delta > 0] = delta[delta > 0]\n",
    "    downs[delta < 0] = -delta[delta < 0]\n",
    "    ups[ups.index[period-1]] = np.mean( ups[:period] )\n",
    "    ups = ups.drop(ups.index[:(period-1)])\n",
    "    downs[downs.index[period-1]] = np.mean( downs[:period] )\n",
    "    downs = downs.drop(downs.index[:(period-1)])\n",
    "    rs = ups.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() /          downs.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() \n",
    "    rsi = 100 - 100 / (1 + rs)\n",
    "\n",
    "    stochrsi  = (rsi - rsi.rolling(period).min()) / (rsi.rolling(period).max() - rsi.rolling(period).min())\n",
    "    stochrsi_K = stochrsi.rolling(smoothK).mean()\n",
    "    stochrsi_D = stochrsi_K.rolling(smoothD).mean()\n",
    "\n",
    "    \n",
    "    condition = False;\n",
    "    yyester_K=stochrsi_K.iloc[-3]*100\n",
    "    yyester_D=stochrsi_D.iloc[-3]*100\n",
    "    yester_K=stochrsi_K.iloc[-2]*100\n",
    "    yester_D=stochrsi_D.iloc[-2]*100\n",
    "    today_K=stochrsi_K.iloc[-1]*100\n",
    "    today_D=stochrsi_D.iloc[-1]*100\n",
    "    if(yyester_K<yester_K and yester_K<today_K and today_K > today_D amd today_D < 60):\n",
    "        condition=True\n",
    "    return condition\n",
    "\n",
    "#스토캐스틱 240min (반환값 매수조건만족시 True 나머지는 False)\n",
    "def stockrsi240(symbol):\n",
    "    url = \"https://api.upbit.com/v1/candles/minutes/240\"\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    series=df['trade_price'].iloc[::-1]\n",
    "\n",
    "    df = pd.Series(df['trade_price'].values)\n",
    "\n",
    "    period=19\n",
    "    smoothK=3\n",
    "    smoothD=3\n",
    "\n",
    "    delta = series.diff().dropna()\n",
    "    ups = delta * 0\n",
    "    downs = ups.copy()\n",
    "    ups[delta > 0] = delta[delta > 0]\n",
    "    downs[delta < 0] = -delta[delta < 0]\n",
    "    ups[ups.index[period-1]] = np.mean( ups[:period] )\n",
    "    ups = ups.drop(ups.index[:(period-1)])\n",
    "    downs[downs.index[period-1]] = np.mean( downs[:period] )\n",
    "    downs = downs.drop(downs.index[:(period-1)])\n",
    "    rs = ups.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() /          downs.ewm(com=period-1,min_periods=0,adjust=False,ignore_na=False).mean() \n",
    "    rsi = 100 - 100 / (1 + rs)\n",
    "\n",
    "    stochrsi  = (rsi - rsi.rolling(period).min()) / (rsi.rolling(period).max() - rsi.rolling(period).min())\n",
    "    stochrsi_K = stochrsi.rolling(smoothK).mean()\n",
    "    stochrsi_D = stochrsi_K.rolling(smoothD).mean()\n",
    "\n",
    "\n",
    "    condition = False;\n",
    "    yyester_K=stochrsi_K.iloc[-3]*100\n",
    "    yyester_D=stochrsi_D.iloc[-3]*100\n",
    "    yester_K=stochrsi_K.iloc[-2]*100\n",
    "    yester_D=stochrsi_D.iloc[-2]*100\n",
    "    today_K=stochrsi_K.iloc[-1]*100\n",
    "    today_D=stochrsi_D.iloc[-1]*100\n",
    "    if(yyester_K<yester_K and yester_K<today_K and today_D <=70):\n",
    "        condition=True\n",
    "    return condition\n",
    "\n",
    "#macd 1day (반환값 매수조건만족시 True 나머지는 False)\n",
    "def macddays(symbol):\n",
    "\n",
    "    url = \"https://api.upbit.com/v1/candles/days\"\n",
    "\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    df=df.iloc[::-1]\n",
    "\n",
    "    df=df['trade_price']\n",
    "\n",
    "    exp1 = df.ewm(span=12, adjust=False).mean() \n",
    "    exp2 = df.ewm(span=26, adjust=False).mean()\n",
    "    macd = exp1-exp2\n",
    "    exp3 = macd.ewm(span=9, adjust=False).mean()  #signal\n",
    "\n",
    "    condition = False\n",
    "    if(macd[2]<macd[1] and macd[1]<macd[0] and macd[0] >exp3[0]):\n",
    "        condition = True\n",
    "\n",
    "    return condition\n",
    "\n",
    "#macd 60분 (반환값 매수조건만족시 True 나머지는 False)\n",
    "def macd60m(symbol):\n",
    "\n",
    "    url = \"https://api.upbit.com/v1/candles/minutes/60\"\n",
    "\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    df=df.iloc[::-1]\n",
    "\n",
    "    df=df['trade_price']\n",
    "\n",
    "    exp1 = df.ewm(span=12, adjust=False).mean() \n",
    "    exp2 = df.ewm(span=26, adjust=False).mean()\n",
    "    macd = exp1-exp2\n",
    "    exp3 = macd.ewm(span=9, adjust=False).mean()  #signal\n",
    "\n",
    "    condition = False\n",
    "    if((macd[1]-exp3[1])> 0 or (macd[0]-exp3[0]) > 0):\n",
    "        condition = True\n",
    "\n",
    "    return condition\n",
    "\n",
    "#MACD 30분 (반환값 매수조건만족시 True 나머지는 False)\n",
    "def macd30m(symbol):\n",
    "\n",
    "    url = \"https://api.upbit.com/v1/candles/minutes/30\"\n",
    "\n",
    "\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "\n",
    "    df=df.iloc[::-1]\n",
    "\n",
    "    df=df['trade_price']\n",
    "\n",
    "    exp1 = df.ewm(span=12, adjust=False).mean() \n",
    "    exp2 = df.ewm(span=26, adjust=False).mean()\n",
    "    macd = exp1-exp2\n",
    "    exp3 = macd.ewm(span=9, adjust=False).mean()  #signal\n",
    "    condition = False\n",
    "    if((macd[1]-exp3[1])<(macd[0]-exp3[0])):\n",
    "        condition = True\n",
    "        \n",
    "    return condition\n",
    "\n",
    "#OBV 값 구하는 함수\n",
    "def OBV(tradePrice, volume):\n",
    "    obv = pd.Series(index=tradePrice.index)\n",
    "    obv.iloc[0] = volume.iloc[0]\n",
    "    \n",
    "    for i in range(1,len(tradePrice)):\n",
    "        if tradePrice.iloc[i] > tradePrice.iloc[i-1] : \n",
    "            obv.iloc[i] = obv.iloc[i-1] + volume[i]\n",
    "            \n",
    "        elif tradePrice.iloc[i] < tradePrice.iloc[i-1] :\n",
    "            obv.iloc[i] = obv.iloc[i-1] - volume[i]\n",
    "            \n",
    "        else:\n",
    "            obv.iloc[i] = obv.iloc[i-1]\n",
    "            \n",
    "    return obv\n",
    "\n",
    "#코인의 OBV 매수조건 테스트 (반환값 매수조건만족시 True 나머지는 False)\n",
    "def obv(symbol):\n",
    "    \n",
    "    url = \"https://api.upbit.com/v1/candles/days\"\n",
    "    querystring = {\"market\":symbol,\"count\":\"200\"}\n",
    "\n",
    "    response = requests.request(\"GET\", url, params=querystring)\n",
    "\n",
    "    data = response.json()\n",
    "\n",
    "    df = pd.DataFrame(data)\n",
    "    df=df.iloc[::-1]\n",
    "\n",
    "    obv = OBV(df['trade_price'],df['candle_acc_trade_volume'])\n",
    "    condition= False\n",
    "    if(obv[2]<obv[1] and obv[1]<obv[0]):\n",
    "        condition = True\n",
    "    \n",
    "    return condition    \n",
    "\n",
    "\n",
    "#내 KRW 자산 조회\n",
    "def get_my_KRW_Balance():\n",
    "    return upbit.get_balance(\"KRW\")\n",
    "\n",
    "\n",
    "\n",
    "# 모든 매수조건 만족 테스트\n",
    "def buy_test (symbol):\n",
    "    test = False\n",
    "    if(stockrsiweeks(symbol) and macd60m(symbol) and macd30m(symbol) and stockrsi240(symbol) and stockrsi60(symbol)):\n",
    "        test = True\n",
    "    return test\n",
    "\n",
    "def buy_overlap_test (symbol, buy_list):\n",
    "    test = True\n",
    "    for i in range(len(buy_list)):\n",
    "        if (symbol == buy_list[i][0]):\n",
    "            test = False\n",
    "    return test\n",
    "\n",
    "\n",
    "########### 메인 로직 ##############################################\n",
    "\n",
    "post_message(myToken,\"#upbit\", \"autotrade start\")\n",
    "\n",
    "#익절의 경우 이틀전종가, 하루전종가, 오늘최고가 기준 -2퍼아래로 떨어졌을 경우 매도.\n",
    "good_sell_list = []\n",
    "#매수할 때 -2퍼 조정이 왔을 때 매수.\n",
    "buy_list = []\n",
    "wantgood_sell_list = []\n",
    "while True:\n",
    "    sell_list = []\n",
    "    try:\n",
    "        #매수조건 테스트 및 매수된 종목들 sell_list에 넣는 작업\n",
    "        my_blance = get_my_KRW_Balance()\n",
    "        for symbol in krw_tickers:\n",
    "            #최근 체결된 코인 정렬\n",
    "            order_done = upbit.get_order(symbol, state=\"cancel\") +upbit.get_order(symbol, state=\"done\") \n",
    "            \n",
    "            if ( [] != order_done): #빈 배열이 있을때 오류가 나지않게하기위해서\n",
    "                order_done_sorted = sorted(order_done, key=(lambda x: x['created_at']), reverse=True)\n",
    "            if(order_done == []):\n",
    "                order_done_sorted = []\n",
    "            \n",
    "            #매수 조건 만족 시 \n",
    "            #0 코인명, 1 매수 조건 만족 했을 때 가격, 2 매수 조건이 왔을 때 +6시간\n",
    "            if(order_done ==[] or order_done_sorted[0]['side'] == 'ask' ):\n",
    "                if(my_blance>invest_money):\n",
    "                    if(buy_overlap_test(symbol,buy_list) and buy_test(symbol)):  #buy overlap test를 해준 후 buy_test 실행\n",
    "                        current_price = pyupbit.get_current_price(symbol)\n",
    "                        current_time = datetime.datetime.now() \n",
    "                        hour_later = current_time + datetime.timedelta(hours=6) \n",
    "\n",
    "                        temp_buy_list = []\n",
    "                        temp_buy_list.append(symbol)\n",
    "                        temp_buy_list.append(current_price)\n",
    "                        temp_buy_list.append(hour_later)\n",
    "                        buy_list.append(temp_buy_list)        \n",
    "            \n",
    "            #최근 체결이 매수인 코인들을 temp_list에 넣고 마지막에 2차원배열 형태로 sell_list에 insert함\n",
    "            if(order_done_sorted != []):\n",
    "                if(order_done_sorted[0]['side'] == 'bid' and float(order_done_sorted[0]['executed_volume']) != 0):\n",
    "\n",
    "                    #구매할 때 코인가격\n",
    "\n",
    "                    coin_buy_price = int(float(order_done_sorted[0]['price'])/float(order_done_sorted[0]['executed_volume']))\n",
    "                    #코인개수\n",
    "                    coin_count = float(order_done_sorted[0]['executed_volume'])\n",
    "\n",
    "                    #0 코인명, 1 구매할때 코인가격, 2 코인개수\n",
    "                    temp_list =[]\n",
    "                    temp_list.append(order_done_sorted[0]['market'])\n",
    "                    temp_list.append(coin_buy_price)\n",
    "                    temp_list.append(coin_count)\n",
    "                    sell_list.append(temp_list)\n",
    "                \n",
    "\n",
    "        #매수\n",
    "        #매수 조건이 온 후 12시간이 지났을 때 매수종목 제거\n",
    "        # + 조정이 왔을 때 매수\n",
    "        if(my_blance>invest_money and buy_list != []):\n",
    "            current_time = datetime.datetime.now() \n",
    "            for i in range(len(buy_list)):\n",
    "                if(buy_list[i][2]<current_time):\n",
    "                    del buy_list[i]\n",
    "\n",
    "            for buy in buy_list:\n",
    "                current_price = pyupbit.get_current_price(buy[0])\n",
    "                if(buy[1]*buydown_percent > current_price):\n",
    "                    buy_result = upbit.buy_market_order(buy[0], invest_money)\n",
    "                    post_message(myToken,\"#upbit\", buy[0]+\"coin buy : \" +str(buy_result))\n",
    "                    \n",
    "                    \n",
    "                    contem = 999 #임시 숫자\n",
    "                    for i in range(len(buy_list)):\n",
    "                        if(buy_list[i][0] == buy[0]):\n",
    "                            contem = i\n",
    "                    if(contem != 999):\n",
    "                        del buy_list[contem]\n",
    "        #매도\n",
    "        if(sell_list != []):\n",
    "            for sell_symbol in sell_list:\n",
    "                current_price = pyupbit.get_current_price(sell_symbol[0])\n",
    "                \n",
    "                #손절\n",
    "                if(sell_symbol[1]*deadsell_percent > current_price):\n",
    "                    sell_result = upbit.sell_market_order(sell_symbol[0], sell_symbol[2])\n",
    "                    post_message(myToken,\"#upbit\", sell_symbol[0]+\"coin dead sell : \" +str(sell_result))\n",
    "                \n",
    "                \n",
    "                \n",
    "                #애매한 익절목표\n",
    "                #wantgood_sell_list 중복체크\n",
    "                want_overlap_test = True\n",
    "                if([] != wantgood_sell_list):\n",
    "                    for i in wantgood_sell_list:\n",
    "                        if(i == sell_symbol[0]):\n",
    "                            want_overlap_test = False                \n",
    "                #wantgood_sellminus_percent퍼 떨어지면 wantgood리스트에 보관 후에 3퍼이상일때 매도\n",
    "                if(want_overlap_test and sell_symbol[1]*wantgood_sellminus_percent>current_price):\n",
    "                    wantgood_sell_list.append(sell_symbol[0])\n",
    "\n",
    "                #good_sell_list에 있는 코인을 익절조건 테스트\n",
    "                if([] != wantgood_sell_list):\n",
    "                    for wantgood_sell in wantgood_sell_list:\n",
    "                        if(wantgood_sell == sell_symbol[0]):\n",
    "                            if(current_price > sell_symbol[1]*1.02):\n",
    "                                sell_result = upbit.sell_market_order(sell_symbol[0], sell_symbol[2])\n",
    "                                post_message(myToken,\"#upbit\", sell_symbol[0]+\"coin wantgood sell : \" +str(sell_result))\n",
    "                                \n",
    "                                #wantgood_sell_list에 있는 코인을 제거해줌\n",
    "                                contem = 999\n",
    "                                for i in range(len(wantgood_sell_list)):\n",
    "                                    if(wantgood_sell_list[i] == sell_symbol[0]):\n",
    "                                        contem = i\n",
    "                                if(contem != 999):\n",
    "                                    del wantgood_sell_list[contem]           \n",
    "\n",
    "\n",
    "\n",
    "\n",
    "                #익절\n",
    "\n",
    "                #good_sell_list 중복체크\n",
    "                overlap_test = True\n",
    "                if([] != good_sell_list):\n",
    "                    for i in good_sell_list:\n",
    "                        if(i == sell_symbol[0]):\n",
    "                            overlap_test = False\n",
    "                            \n",
    "                #현재가가 매수 * goodsell_percent 보다 높아졌을 때 good_sell_list에 코인명을 추가\n",
    "                if(overlap_test and sell_symbol[1] * goodsell_percent < current_price):\n",
    "                    good_sell_list.append(sell_symbol[0])\n",
    "\n",
    "                #good_sell_list에 있는 코인을 익절조건 테스트\n",
    "                if([] != good_sell_list):\n",
    "                    for good_sell in good_sell_list:\n",
    "                        if(good_sell == sell_symbol[0]):\n",
    "                            df = pyupbit.get_ohlcv(sell_symbol[0], count=3)\n",
    "\n",
    "                            #이틀전,하루전 종가와 당일고가 중 가장 높은 가격을 구함\n",
    "                            most_high = df.iloc[2]['high'] #당일 고가\n",
    "                            if(most_high < df.iloc[0]['close']): \n",
    "                                most_high = df.iloc[0]['close'] #이틀전 종가\n",
    "                            if(most_high < df.iloc[1]['close']):\n",
    "                                most_high = df.iloc[1]['close'] #하루전 종가\n",
    "\n",
    "                            #current_price와 most_high를 비교해서 매도\n",
    "                            if(most_high *aftergoodsell_percent >current_price):\n",
    "                                sell_result = upbit.sell_market_order(sell_symbol[0], sell_symbol[2])\n",
    "                                post_message(myToken,\"#upbit\", sell_symbol[0]+\"coin good sell : \" +str(sell_result))\n",
    "\n",
    "                                #good_sell_list에 있는 코인을 제거해줌\n",
    "                                contem = 999\n",
    "                                for i in range(len(good_sell_list)):\n",
    "                                    if(good_sell_list[i] == sell_symbol[0]):\n",
    "                                        contem = i\n",
    "                                if(contem != 999):\n",
    "                                    del good_sell_list[contem]\n",
    "\n",
    "\n",
    "                 \n",
    "        time.sleep(2)\n",
    "\n",
    "    except Exception as e:\n",
    "        print(e)\n",
    "        post_message(myToken,\"#upbit\", e)\n",
    "        time.sleep(1)\n",
    "\n",
    "        \n"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.9.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
